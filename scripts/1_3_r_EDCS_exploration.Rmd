---
title: "EDCS cleaning of the epigraphic text"
author: "Petra Hermankova"
date: "10/12/2020"
output:
  html_document:
    theme: united
    toc: yes
    toc_float: true
    number_sections: true
    toc_depth: 2
    df_print: paged
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/petra/Github/ClaussSlaby_ETL/")

library(tidyverse)
library(jsonlite)
library(data.table)
library(leaflet)
library(sdam)
```

## Loading data
Load the dataset, if you have Sciencedata.dk credentials

```{r, echo=FALSE}
mycred_secret<- readLines("~/mysecret.txt")
```

```{r, loading data}
resp = request("EDCS_text_cleaned_2021-01-20.json", path="/sharingin/648597@au.dk/SDAM_root/SDAM_data/EDCS/public", method="GET", cred=mycred_secret)
```

```{r, echo=FALSE}
remove(mycred_secret)
```

OR of you don't have Sciencedata credentials:
```{r, loading data public, eval=FALSE}
#The folder still needs to made public by owner (Vojtech Kase)
resp = request("EDCS_text_cleaned_2020-12-29.json", path="/sharingin/648597@au.dk/SDAM_root/SDAM_data/EDCS/public", method="GET")
```

Make a list and tibble from the downloaded dataset
```{r}
list_json <- jsonlite::fromJSON(resp)
EDCS = as_tibble(list_json)
```

# Dataset exploration

```{r}
names(EDCS)
```

```{r}
head(EDCS)
```


## How many inscriptions there are in total?
```{r}
nrow(EDCS)
```


## Language

### How many and which combinations of languages contain inscription in Greek?
```{r}
grep(x = EDCS$language, "GR", value = TRUE) %>%
  table()
```

### How many inscriptions have GR as one of their languages?
```{r}
grep(x = EDCS$language, "GR", value = TRUE) %>%
  length() -> greek

greek

greek/(nrow(EDCS)/100)
```
### How many and which combinations of languages are in EDCS?
```{r}
unique(EDCS$language)
```


## Province
```{r}
EDCS %>%
  count(province, sort = TRUE)
```
Some inscriptions have double provinces:

Belgica | Germania inferior
Pannonia inferior | Pannonia superior
Moesia inferior | Moesia superior

```{r}
str_split_fixed(EDCS$province, pattern = " \\| ", n=2) %>% as.data.frame() -> provinces

provinces %>%
  cbind(combined = c(provinces$V1, provinces$V2)) %>%
  filter(combined != "") -> provinces

provinces %>%
  count(combined, sort=TRUE)
```


# How many inscriptions are linked to EDH

```{r}
length(str_subset(EDCS$Links, "heidelberg"))
```

# How many inscriptions are linked to PHI

```{r}
length(str_subset(EDCS$Links, "epigraphy.packhum"))
```

# Status attribute

******************************NEEDS updating 



### Type of inscription
```{r}
EDCS %>%
    count(inscr_type)
```

### Type of inscribing process
```{r}
EDCS %>%
    count(inscribing_process)
```


### Type of status notation
```{r}
EDCS %>%
  count(status_notation)
```


## Coordinates

### Which inscriptions have geospatial coordinates?
```{r}
EDCS %>%
  dplyr::filter(!is.na(Latitude)) -> location
# how many inscriptions have latitude
nrow(location)
# how many % of inscriptions have latitude
nrow(location)/(nrow(EDCS)/100)
```

```{r}
location$Latitude <- as.numeric(location$Latitude)
location$Longitude <- as.numeric(location$Longitude)
```

```{r}
location$ID <- location$`EDCS-ID`
head(location)

```

### How precise are the coordinates (how many decimal numbers have) 
```{r}
decimalplaces<-function(x) {
  x_str <- toString(x)
  x_str<- str_split(x_str, "\\.")
  nchar(x_str[[1]][2])
}

### latitude
lat_df<- as.data.frame(EDCS$Latitude) %>%  
  mutate(decimals = unlist(map(EDCS$Latitude, decimalplaces)))

lat_df_count<- lat_df %>% 
  count(decimals, sort = T) %>% 
  mutate(percent = n/(sum(n)/100))

lat_df_count

### longitude
long_df<- as.data.frame(EDCS$Longitude) %>%  
  mutate(decimals = unlist(map(EDCS$Longitude, decimalplaces)))

long_df_count<- long_df %>% 
  count(decimals, sort = T) %>% 
  mutate(percent = n/(sum(n)/100))

long_df_count
```


### Mapped inscriptions with known coordinates - for full dataset be careful before running
```{r}
map_all <- leaflet(width="100%") %>%
 addProviderTiles("Stamen.TerrainBackground")%>% # Add CartoDB map tiles
# addProviderTiles("Stamen.Watercolor")%>% # Add CartoDB map tiles
# addProviderTiles("Esri.WorldImagery", group = "ESRI Aerial") %>%
# addPolylines(data = roads, color = "purple", weight = 2, opacity = 0.7) %>%
  setView( lng = 22.326743, lat = 46.897122, zoom = 4 ) %>%
  #setMaxBounds(lat1=43.633977, lng1 =-11.227926 , lat2=35.133882 , lng2=50.882336) %>%
#  addCircles(lng = location$Longitude, lat = location$Latitude, opacity = 0.5, radius = 10, fill = TRUE, color = "grey" , fillColor = "white",) %>%
  addCircles(lng = location$Longitude,  
             lat = location$Latitude, opacity = 0.5, radius = 10, fill = TRUE, color = "purple" , fillColor = "",
             popup = paste0("<b> InscriptionID: </b>", location$ID
                             # "<br><b> Province: </b>", location$province,
                             #<br><b> Type of inscription: </b>", lat_long_milestone$type_of_inscription_clean,
                             # "<br><b> Type of monument: </b>", lat_long_milestone$type_of_monument_clean,
                             # "<br><b> Not before (date): </b>", lat_long_milestone$not_before,
                             # "<br><b> Not after (date): </b>", lat_long_milestone$not_after,
                             #   "<br><b> Commentary: </b>", lat_long_milestone$commentary,
                            )
             ) %>%
addLegend(position = "topright",
  colors = c("Purple"),
  labels = c("Inscription (n = 383,322)"), opacity = 1,
  title = "Inscriptions in the EDCS database"
)
map_all
```



# Dates

## Start year
```{r}
EDCS %>%
  filter(!is.na(EDCS$`dating from`)) -> has_start_yr
# how many inscriptions have start year
nrow(has_start_yr)
# how many inscriptions have start year in %
nrow(has_start_yr)/(nrow(EDCS)/100)
```

## End year
```{r}
EDCS %>%
  filter(!is.na(EDCS$`dating to`)) -> has_end_yr
# how many inscriptions have end year
nrow(has_end_yr)
# how many inscriptions have end year in %
nrow(has_end_yr)/(nrow(EDCS)/100)
```

### Date Range
```{r}
unique(has_end_yr$`dating to`)
class(has_end_yr$`dating to`)

unique(has_end_yr$`dating to`)
```

```{r}
EDCS<- EDCS %>% 
  mutate(date_from_1 = as.numeric(str_extract(EDCS$`dating from`, pattern = "^[-]*[:digit:]+"))) %>% 
  mutate(date_to_1 = as.numeric(str_extract(EDCS$`dating to`, pattern = "^[-]*[:digit:]+")))
```

```{r}
summary(EDCS$date_from_1)

plot(table(EDCS$date_from_1))
```

```{r}

summary(EDCS$date_to_1)
plot(table(EDCS$date_to_1))
```
Both dates
```{r}
EDCS %>% 
  filter(!is.na(date_from_1) & !is.na(date_to_1)) -> has_both_dates

nrow(has_both_dates)/(nrow(EDCS)/100)
```


# Material

```{r}
EDCS %>%
  count(Material, sort= TRUE)
```

# Comments

```{r}
unique(EDCS$Comment)
```

# Text of inscription

## How many inscriptions contain a text of an inscription

```{r}
length(na.omit(EDCS$clean_text_interpretive_word))
```
In percent:
```{r}
length(na.omit(EDCS$clean_text_interpretive_word))/(nrow(EDCS)/100)
```

## How many words there are:

Original text before cleaning:
```{r}
sum(lengths(gregexpr("\\w+", EDCS$inscription)) + 1)

#different counting method
sum(na.omit(str_count(EDCS$inscription, '\\w+')))
```

Text after cleaning:
```{r}
sum(lengths(gregexpr("\\w+", EDCS$clean_text_interpretive_word)) + 1)

#different counting method
sum(na.omit(str_count(EDCS$clean_text_interpretive_word, '\\w+')))
```







