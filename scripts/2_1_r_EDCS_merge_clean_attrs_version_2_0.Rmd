---
title: "EDCS_version_2_0"
author: "Petra Hermankova"
date: "22/07/2021"
output:
  html_document:
    theme: united
    toc: yes
    toc_float: true
    number_sections: true
    toc_depth: 2
    df_print: paged
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/petra/Github/ClaussSlaby_ETL/")

library(tidyverse)
library(jsonlite)
library(data.table)
library(leaflet)
library(sdam)
```

# Merging the CSV files into one dataframe
```{r}
# listing all tsv files
temp <- list.files(path= "../data/2021_07_21_allProvinces", pattern = "*.tsv")
```

## Loading data from multiple TSV files into one dataframe

```{r}
setwd("~/Github/EDCS_ETL/data/2021_07_21_allProvinces")
# loading multiples files
EDCS <- temp %>% map_df(~read_tsv(., col_types = cols(.default = "c")))

setwd("/home/petra/Github/ClaussSlaby_ETL/")
```

```{r}
head(EDCS)
```

```{r}
names(EDCS)
```

# Cleaning attributes

Some of the attributes need to be streamlined as they contain either lists of values rathen than individual observations, but they have a form of a text string. They need to be converted to a list so they can be analysed computationally.

## Cleaning place attribute

Transforming string character into list for better manipulation.
```{r}
EDCS$place_list<- str_split(EDCS$place, " / ")
```

How many unique place names there is?
```{r}
length(unique(unlist(EDCS$place_list)))
```

## Cleaning `dating` attribute

```{r}
table(EDCS$`dating`)
```


1. Transforming string containing multiple values into a list (split by ;)
2. Delete a: XXX; b: XXX pattern 
3. Spliting date to start and end date by ` to `
4. Select relevant values to three columns: not_before, not_after, extra_dates
5. Transforming character into numeric value.

```{r}
date<- as.list(str_split(EDCS$dating, "; "))
date100 <- date 
```

```{r}
# eliminate a: XXX b: XXX pattern
date100a <- lapply(date100, str_replace_all, ".*[:lower:]:\\s+", "")
date100a 

# split on ` to `
date100b <- lapply(date100a, strsplit, split = " to ")
date100b

# choose first element of the main list
date100c<- map(date100b, 1)
date100c

# choose first element of nested list (start date)
date100d <- map(date100c, 1)
date100d

date100d<- replace(date100d, sapply(date100d, is.null), NA)

not_before <- do.call(rbind.data.frame, date100d)
colnames(not_before) <- c('not_before')

# choose second element of nested list (end date)
date100e <- map(date100c, 2)
date100e

date100f<- replace(date100e, sapply(date100e, is.null), NA)
date100f

not_after <- do.call(rbind.data.frame, date100f)
colnames(not_after) <- c('not_after')
not_after

# combine them back together
date_df<- cbind(not_before, not_after)
date_df
```



```{r}
dated<- date_df %>% 
  filter(!is.na(not_before) & !is.na(not_after)) %>% 
  nrow()

# how many inscriptions are dated
dated/(nrow(date_df)/100)
```

# Checking the values

```{r}
EDCS %>% 
  select(dating, not_before, not_after)
```

## Appending to the main dataframe

```{r}
EDCS <- cbind(EDCS, date_df)
```




## Cleaning 'status' attribute

```{r}
EDCS$status_list<- str_split(EDCS$status, "; ")
```

### Categorisation based on the typology of keyword in the attribute status:

```{r}
inscription_type_list <- c("tituli sepulcrales", "tituli fabricationis", "inscriptiones christianae", "tituli sacri", "tituli possessionis", "tituli operum", "miliaria", "tituli honorarii", "carmina", "signacula", "diplomata militaria", "leges", "defixiones", "termini", "reges", "signacula medicorum", "senatus consulta")

inscribing_process_list <- c("sigilla impressa", "litterae erasae", "litterae in litura", "tesserae nummulariae")

status_notation_list<- c("viri", "tria nomina", "mulieres", "nomen singulare", "liberti/libertae", "milites", "Augusti/Augustae", "ordo senatorius", "servi/servae", "officium/professio", "ordo decurionum", "sacerdotes pagani", "praenomen et nomen", "ordo equester", "seviri Augustales", "sacerdotes christiani")
```

Division the status keywords into their own attributes, base on their purpose:
1. inscription type
2. notation of a societal status of a person on the inscription
3. details about process of inscribing, execution

```{r}
EDCS <- EDCS %>% 
  mutate(inscr_type = str_extract_all(pattern = paste(inscription_type_list, collapse="|"), string = EDCS$status)) %>% 
  mutate(status_notation = str_extract_all(pattern = paste(status_notation_list, collapse="|"), string = EDCS$status)) %>% 
  mutate(inscr_process = str_extract_all(pattern = paste(inscribing_process_list, collapse="|"), string = EDCS$status))
```

#### Convert character (0) to NA

```{r}
EDCS$inscr_type <- lapply(EDCS$inscr_type, function(x) if(identical(x, character(0))) NA_character_ else x)
EDCS$status_notation <- lapply(EDCS$status_notation, function(x) if(identical(x, character(0))) NA_character_ else x)
EDCS$inscr_process <- lapply(EDCS$inscr_process, function(x) if(identical(x, character(0))) NA_character_ else x)
```

## Cleaning 'province' attribute

Some records contain multiple values provinces, separated by |, such as: 

`Belgica | Germania inferior`
`Pannonia inferior | Pannonia superior`
`Moesia inferior | Moesia superior`

```{r}
EDCS$province_list <- str_split(EDCS$province, " \\| ")
```

Listing all the provinces and their variants:
```{r}
unique(EDCS$province_list)
```


# Renaming the columns, so it fits the previous version of the dataset

```{r}

Links <-partner_link

```









# Saving to Science Data

```{r, echo=FALSE}
mycred_secret<- readLines("~/mysecret.txt")
```

```{r}
EDCS_json <- jsonlite::toJSON(EDCS, auto_unbox=TRUE)
write(EDCS_json, file="EDCS_merged_cleaned_attrs_2021-03-01.json")
request("EDCS_merged_cleaned_attrs_2021-03-01.json", path="/sharingout/648597@au.dk/SDAM_root/SDAM_data/EDCS/public",
        method="PUT", cred=c(mycred_secret[1], mycred_secret[2]))
```

```{r, echo=FALSE}
remove(mycred_secret)
```
